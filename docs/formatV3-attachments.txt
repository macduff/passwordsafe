PasswordSafe database format description version 3.23
-----------------------------------------------------

Copyright (c) 2003-2010 Rony Shapiro <ronys@users.sourceforge.net>.
All rights reserved. Use of the code is allowed under the Artistic
License terms, as specified in the LICENSE file distributed with this
code, or available from
http://www.opensource.org/licenses/artistic-license-2.0.php

This document is based on the FormatV3.txt document describing the
format of the V3 PasswordSafe database.

1. Introduction: This document defines a file format for the secure
storage of related data as a separate file to the main PasswordSafe
database. The format is designed according to current cryptographic
best practices, and is believed to be secure, in the sense that without
knowledge of the master passphrase, only a brute-force attack or a
flaw in the underlying cryptographic algorithm will result in
unauthorized access to the data.

1.1 Design Goals: The PasswordSafe database format is designed to be
secure, extensible and platform-independent.

1.2 History: This specification is an evolution of previous
formats. The main differences between version 3 of the format and
previous versions are:
1.2.1. This version addresses a minor design flaw in previous versions
of the PasswordSafe database format.
1.2.3. This version replaces the underlying cryptographic functions
with more advanced versions.
1.2.4. This version allows the detection of a truncated or
corrupted/tampered database.

Meeting these goals is impossible without breaking compatibility: This
format is NOT compatible with previous (major) versions. Note,
however, that since the data stored in previous versions is a proper
subset of the data described here, implementers may read a database
written in an older version and store the result in the format
described here.

2. Format: V3 format PasswordSafe attachment files are structured as follows:

Index file:
    TAG|SALT|ITER|H(P')|B1|B2|B3|B4|IV|HDR|I1|I2|...|In|IEOF|HMAC

Data file:
    TAG|SALT|ITER|H(P')|B1|B2|B3|B4|IV|HDR|D1|D2|...|Dn|DEOF|HMAC

*** Note: If we assume the same passphrase and key as the primary database,
then the SALT, ITER, H(p'), B1, B2, B3, B4 & IV fields will not be needed!


Where:

2.1 TAG is the sequence of 4 ASCII characters "PAI3" for the Index file and
"PAD3" for the Data file. This is to serve as a quick way for the application
to identify the database as a PasswordSafe version 3 file. This tag has no
cryptographic value.

2.1 SALT is a 256 bit random value, generated at file creation time.

2.3 P' is the "stretched key" generated from the user's passphrase and
the SALT, as defined in by the hash-function-based key stretching
algorithm in [KEYSTRETCH] (Section 4.1), with SHA-256 [SHA256] as the
hash function, and ITER iterations (at least 2048, i.e., t = 11).

2.4 ITER is the number of iterations on the hash function to calculate P',
stored as a 32 bit little-endian value. This value is stored here in order
to future-proof the file format against increases in processing power.

2.5 H(P') is SHA-256(P'), and is used to verify that the user has the
correct passphrase.

2.6 B1 and B2 are two 128-bit blocks encrypted with Twofish [TWOFISH]
using P' as the key, in ECB mode. These blocks contain the 256 bit
random key K that is used to encrypt the actual records. (This has the
property that there is no known or guessable information on the
plaintext encrypted with the passphrase-derived key that allows an
attacker to mount an attack that bypasses the key stretching
algorithm.)

2.7 B3 and B4 are two 128-bit blocks encrypted with Twofish using P' as the
key, in ECB mode. These blocks contain the 256 bit random key L that is
used to calculate the HMAC (keyed-hash message authentication code) of the
encrypted data. See description of EOF field below for more details.
Implementation Note: K and L must NOT be related.

2.8 IV is the 128-bit random Initial Value for CBC mode.

2.9 All following records are encrypted using Twofish in CBC mode, with K
as the encryption key.

2.9.1 HDR: The database header. The header consists of one or more typed
fields (as defined in section 3.2), terminated by the 'END' type field. The
version number field is mandatory. Aside from the 'END' field, no
order is assumed on the field types.

2.9.2 I1..In: The index records. Each record consists of one or
more typed fields (as defined in Section 3.2), terminated by the 'END' type
field. When a field is absent or zero-length, its default value shall be
used. The 'Record Type' field MUST be the first field and the 'END' field
MUST be the last field. No order is assumed on the intervening field types.

2.9.3 D1..Dn: The data records. Each record consists of one or
more typed fields (as defined in Section 3.2), terminated by the 'END' type
field. When a field is absent or zero-length, its default value shall be
used.  The 'Record Type' field MUST be the first field and the 'END' field
MUST be the last field. No order is assumed on the intervening field types.

2.10 EOF: The ASCII characters "PAx3-EOFPAx3-EOF", where 'x' = 'I' for the
index file and 'D' for the data file (note that this is exactly one block
long), unencrypted. This is an implementation convenience to inform the
application that the following bytes are to be processed differently.

2.11 HMAC: The 256-bit keyed-hash MAC, as described in RFC2104, with SHA-
256 as the underlying hash function. The value is calculated over all of
the plaintext fields, that is, over all the data stored in all fields
(starting from the version number in the header, ending with the last field
of the last record). The key L, as stored in B3 and B4, is used as the hash
key value.

3. Fields: Data in PasswordSafe is stored in typed fields. Each field
consists of one or more blocks. The blocks are the blocks of the underlying
encryption algorithm - 16 bytes long for Twofish. The first block contains
the field length in the first 4 bytes (little-endian), followed by a one-
byte type identifier. The rest of the block contains up to 11 bytes of
record data. If the record has less than 11 bytes of data, the extra bytes
are filled with random values. The type of a field also defines the data
representation.

3.1 Data representations
3.1.1 UUID
 The UUID data type is 16 bytes long, as defined in RFC4122. Microsoft
 Windows has functions for this, and the RFC has a sample
 implementation.

3.1.2 Text
 Text is represented in UTF-8 encoding (as defined in RFC3629), with
 no byte order marker (BOM) and no end-of-string mark (e.g., null
 byte). Note that the latter isn't neccessary since the length of the
 field is provided explicitly. Note that ALL fields described as
 "text" are UTF-8 encoded unless explicitly stated otherwise.

3.1.3 Time
 Timestamps are stored as 32 bit, little endian, unsigned integers,
 representing the number of seconds since Midnight, January 1, 1970, GMT.
 (This is equivalent to the time_t type on Windows and POSIX. On the
 Macintosh, the value needs to be adjusted by the constant value 2082844800
 to account for the different epoch of its time_t type.)
 Note that future versions of this format may allow time to be
 specifed in 64 bits as well.

3.2 Field types for the PasswordSafe database header:
                                                 Currently
Name                        Value        Type    Implemented      Comments
--------------------------------------------------------------------------
Version                     0x00        2 bytes       Y              [1]
File type                   0x01        1 byte        Y              [2]
UUID of Index file          0x02        UUID          Y              [3]
UUID of Data file           0x03        UUID          Y              [4]
UUID of associated database 0x04        UUID          Y              [5]
Timestamp of last save      0x05        time_t        Y              [6]
What performed last save    0x06        Text          Y              [7]
Last saved by user          0x07        Text          Y              [8]
Last saved on host          0x08        Text          Y              [9]
End of Entry                0xff        [empty]       Y              [10]

[1] The version number of the database format. For this version, the value
is 0x8301 (stored in little-endian format, that is, 0x01, 0x83).  Note that
the main database does not have the first bit of the version set.
PasswordSafe V3.23 introduced Format 0x8301

[2] File type = 0x01 for Index, 0x02 for Data.

[3] A universally unique identifier for the index file of attachments.

[4] A universally unique identifier for the data file of attachments.

[5] The UUID of the associated database.

[6] Representation is as described in Section 3.1.3.

[7] Free form text giving the application that saved the database.
For example, the Windows PasswordSafe application will use the text
"Password Safe Vnn.mm", where nn and mm are the major and minor
version numbers. The major version will contain only the significant
digits whereas the minor version will be padded to the left with
zeroes e.g. "Password Safe V3.23".

[8] Text containing the username (e.g., login, userid, etc.) of the
user who last saved the database, as determined by the appropriate
operating-system dependent function.

[9] Text containing the hostname (e.g., machine name, hostid, etc.) of the
machine on which the database was last saved, as determined by the
appropriate operating-system dependent function.

[10] An explicit end of entry field is useful for supporting new fields
without breaking backwards compatability.

3.3 Field types for Attachement Records:

NOTE THAT UNLIKE THE NORMAL PASSWORDSAFE DATABASE, ENTRY FIELDS MUST BE
WRITTEN TO THE ATTACHMENT DATABASE IN FIELD VALUE ORDER.

                                                 Currently
Name                        Value        Type    Implemented      Comments
---------------------------------------------------------------------------
UUID of this entry           0x01        UUID          Y              [1]
UUID of associated entry     0x02        UUID          Y              [2]
Flags                        0x03        2 characters  Y              [4]
Attachment filename.ext      0x04        Text          Y              [5]
Attachment original path     0x05        Text          Y              [6]
Attachment description       0x06        Text          Y              [7]
Attachment original size     0x07        4 bytes       Y              [8]
Blocksize used to read file  0x08        4 bytes       Y              [9]
Attachment Last Access Time  0x09        time_t        Y              [10]
Attachment Modifed Time      0x0a        time_t        Y              [10]
Attachment Create Time       0x0b        time_t        Y              [10]
Attachment Date added        0x0c        time_t        Y              [10]

Data - Multiple data records 0x80        Text          Y              [11]
Data - Last record           0x81        Text          Y              [11]

Attachment compressed size   0xc0        4 bytes       Y              [12]
Attachment CRC               0xc1        4 bytes       Y              [13]
Attachment odigest           0xc2        20 characters Y              [14]
Attachment cdigest           0xc3        20 characters Y              [15]

End of Entry                 0xff        [empty]       Y              [16]

NOTE:
a. FIELD VALUES < 0x80 CONTAIN STATIC INFORMATION KNOWN AT ATTACHMENT SELECTION.
b. FIELD VALUES 0x80 AND 0x81 CORRESPOND TO THE COMPRESS DATA
c. FIELD VALUES BETWEEN 0xc0 AND 0xce REPRESENT VALUES CALCULATED WHILST PROCESSING
THE ATTACHMENT AND THEREFORE NOT AVAILABLE WHEN THE DATA IS BEING WRITTEN.


[1] Per-record UUID.

[2] UUID of associated entry in main database.

[3] UUID of the corresponding data record.

[4] Flags. Two character hexadecimal represention of a 1 byte field.
The format is: "ff" where:
     ff = 2 hexadecimal digits representing the following flags
        ExtractToRemoveable 0x80  - Only extract to removeable media (e.g. flash)
        ErasePgmExists      0x40  - Only extract if user has specified a file erasure
                                    program and it exists in this environment
        EraseOnDBClose      0x20  - Erase at database close, unless still in use (not
                                    yet implemented)
        Unused              0x1f

[5] The original filename of the attachment, including the file extension,
if present. Maximum length of this field is 255 characters.

[6] The original path of the attachment. Maximum length of this field is 255 characters.

[7] An optional user specfied description of the attachment.

[8] Size of the original file (unsigned 32-bit integer).

[9] Block size used to read original file (unsigned 32-bit integer).  This is required
as the decompression routines need to know the size of buffer into which the compressed
data is decompressed.  This can vary enormously depending on the source data.

[10] Representation is as described in Section 3.1.3. Values taken from file system.

[11] The original data (binary or text) is first compressed using zlib deflate
before adding to this record.  On retrieval and after decryption, the data
is inflated back before writing the data to a file.  data is written in multiple
'data blocks' followed by a 'last data block'.  This allows large attachments to
be processed in chunks allowing user feedback during the process and prevent the 
user thinking the application was stalled.  Although implementation specific,
the current block size is calculated via the formula:
  min(max(MINBLOCKSIZE, filesize/50), MAXBLOCKSIZE)
    where MINBLOCKSIZE is 32KB and MAXBLOCKSIZE is 256KB.
Note that there can be multiple Data records (0 to N) and only one LastData record.

[12] Size of the compressed data (unsigned 32-bit integer).

[13] CRC of the original file before compressed (can be used to compare with values
produced by programs such as WinZip, 7-zip etc.) (unsigned 32-bit integer).

[14] SHA1 digest of the original file before compressed.

[15] SHA1 digest of the compressed file.

[16] An explicit end of entry field is useful for supporting new fields
without breaking backwards compatability.

4. Extensibility

4.1 Forward compatability: Implementations of this format SHOULD NOT
discard or report an error when encountering a field of an unknown
type. Rather, the field(s) type and data should be read, and perserved
when the database is saved.

4.2 Field type identifiers: This document specifies the field type
identifiers for the current version of the format. Compliant
implementations MUST support the mandatory fields, and SHOULD support
the other fields described herein. Future versions of the format may
specify other type identifiers.

4.2.1 Application-unique type identifiers: The type identifiers
0xc0-0xdf are available for application developers on a first-come
first-serve basis. Application developers interested in reserving a
type identifier for their application should contact the maintainer of
this document (Currently the PasswordSafe project administrator at
SourceForge).

4.2.2 Application-specific type identifiers: The type identifiers
0xe0-0xfe are reserved for implementation-specific purposes, and will
NOT be specified in this or future versions of the format
description.

4.2.3 All unassigned identifiers except as listed in the previous two
subsections are reserved, and should not be used by other
implementations of this format specification in the interest of
interoperablity.

4.2.4 The Index and Data EOF records cannot be extended and are limited
to the two fields detailed above.

5. References:
[TWOFISH] http://www.schneier.com/paper-twofish-paper.html
[SHA256]
http://csrc.nist.gov/publications/fips/fips180-2/fips180-2withchangenotice.pdf
[KEYSTRETCH] http://www.schneier.com/paper-low-entropy.pdf

End of Format description.
